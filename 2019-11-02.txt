2019-11-02 00:23:07 <shachaf> Are pointers signed or unsigned?
2019-11-02 00:23:42 <olsner> they could be
2019-11-02 00:24:42 <shachaf> How should I think of them?
2019-11-02 00:24:50 <olsner> what does it actually mean though? when do you have sign/zero-extension of pointers where you could tell the difference?
2019-11-02 00:26:00 <olsner> I do like to think that x86-64 has signed pointers the way they're usually used (with kernel space in negative addresses)
2019-11-02 00:29:43 <shachaf> Right, that's the sort of thing I was thinking.
2019-11-02 00:29:49 <shachaf> Maybe it makes no difference.
2019-11-02 00:30:27 Quit: imode (Ping timeout: 265 seconds)
2019-11-02 00:30:27 Names: \oren\, ^[, aji, aloril, APic, arseniiv, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, oerjan, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 00:32:20 <oerjan> . o O ( the difference is negative )
2019-11-02 00:33:10 <int-e> shachaf: signs are pointers, so pointers should be signed, is that what you mean?
2019-11-02 00:33:42 <shachaf> Exactly.
2019-11-02 00:33:52 <shachaf> But then what are cosigns?
2019-11-02 00:34:26 <int-e> They are orthogonal to signs.
2019-11-02 00:34:56 <shachaf> 17:	76 06                	jbe    1f <foo+0x1f>
2019-11-02 00:34:59 <shachaf> So confusil.
2019-11-02 00:35:27 <shachaf> I just learned about gas "1f" label syntax a few days ago, and I kept thinking it was a 0x1f offset.
2019-11-02 00:35:34 <shachaf> This time it actually is a 0x1f offset!
2019-11-02 00:35:43 <int-e> :)
2019-11-02 00:36:17 <shachaf> (To be fair, this is objdump output, so it wouldn't use the 1f syntax.)
2019-11-02 00:37:18 <int-e> To this day I find it confusing that the offset of relative jumps is relative to the address following the current instruction.
2019-11-02 00:37:37 <int-e> 0x19 + 0x06 = 0x1f
2019-11-02 00:37:55 <shachaf> Yes.
2019-11-02 00:38:20 <shachaf> In particular I was trying to figure out a jump target in gdb a few days and I computed it relative to $rip without thinking.
2019-11-02 00:38:42 <shachaf> No, not a jump target, rip-relative addressing.
2019-11-02 00:39:01 <int-e> It makes sense, of course (the instruction has been decoded, and correspondingly, the IP advanced, when the jump happens)
2019-11-02 00:39:28 <int-e> (thinking in terms of *very* old processors like 8086)
2019-11-02 00:40:29 <shachaf> Sure.
2019-11-02 00:41:54 <shachaf> Is rip-relative addressing the same way? I guess it must be but I've already forgotten.
2019-11-02 00:42:33 <int-e> yes it is.
2019-11-02 00:43:03 <shachaf> Yep, I just checked.
2019-11-02 00:43:23 <shachaf> I should know this since I implemented most of the addressing modes recently.
2019-11-02 00:43:54 <shachaf> Though not some of the weird ones like 64-bit (%eax).
2019-11-02 00:43:57 <shachaf> Does anyone use that?
2019-11-02 00:44:20 <int-e> Actually I think so.
2019-11-02 00:44:29 <shachaf> `asm addr32; mov (%rax),%rdi
2019-11-02 00:44:30 <HackEso> 0:  67 48 8b 38   mov (%eax),%rdi
2019-11-02 00:44:45 Joined: imode
2019-11-02 00:44:45 Names: \oren\, ^[, aji, aloril, APic, arseniiv, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, oerjan, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 00:44:58 <int-e> Having 32bit pointers is still attractive to conserve memory.
2019-11-02 00:45:24 <shachaf> But you can use them with 64-bit registers, can't you?
2019-11-02 00:45:43 <int-e> Yes.
2019-11-02 00:45:44 <olsner> since you get zero-extension for most operations, you can usually just use %rax with a 32-bit address and save a byte
2019-11-02 00:45:51 <shachaf> At least if you write something like mov foo, %eax; mov (%rax), bar
2019-11-02 00:46:24 <shachaf> I wonder, is %eax sign-extended when you use (%eax)?
2019-11-02 00:46:27 <shachaf> I imagine not.
2019-11-02 00:46:46 <int-e> But I can make up reasons... getting proper overflow behavior for (%eax + 4*%esi + 0xbase)....
2019-11-02 00:47:17 <olsner> but what would use something like that in 64-bit code?
2019-11-02 00:47:55 <shachaf> When do you want overflow behavior for addresses?
2019-11-02 00:48:07 <int-e> olsner: I *would* hope that this is a purely theoretical reason :)
2019-11-02 00:48:18 <olsner> but an interesting side-effect if the address size affects all of the address calculation or just the size of the input registers
2019-11-02 00:49:15 <int-e> Clearly I expect that it affects the whole computation.
2019-11-02 00:49:28 <shachaf> `asm mov (%eax,%edx), %edi
2019-11-02 00:49:29 <HackEso> 0:  67 8b 3c 10   mov (%eax,%edx,1),%edi
2019-11-02 00:49:36 <shachaf> `asm mov (%rax,%edx), %edi
2019-11-02 00:49:37 <HackEso> â€‹/tmp/asm.s: Assembler messages: \ /tmp/asm.s:1: Error: `(%rax,%edx)' is not a valid base/index expression \ /tmp/asm.s: Assembler messages: \ /tmp/asm.s:1: Error: missing ')' \ /tmp/asm.s:1: Error: junk `)' after expression
2019-11-02 00:49:51 <shachaf> `asm addr32; mov (%rax,%rdx), %edi
2019-11-02 00:49:51 <HackEso> 0:  67 8b 3c 10   mov (%eax,%edx,1),%edi
2019-11-02 00:50:23 <shachaf> `asm addr32; gs; mov (%rax,%rdx), %edi
2019-11-02 00:50:24 <HackEso> 0:  67 65 8b 3c 10   mov %gs:(%eax,%edx,1),%edi
2019-11-02 00:50:25 <shachaf> `asm gs; addr32; mov (%rax,%rdx), %edi
2019-11-02 00:50:26 <HackEso> 0:  65 67 8b 3c 10   mov %gs:(%eax,%edx,1),%edi
2019-11-02 00:50:35 <shachaf> Just write the prefixes in any order you like. So convenient.
2019-11-02 00:50:50 <shachaf> `asm data16; mov (%rax,%rdx), %edi
2019-11-02 00:50:51 <HackEso> 0:  66 8b 3c 10   mov (%rax,%rdx,1),%di
2019-11-02 00:51:05 <shachaf> Golly.
2019-11-02 00:51:30 <shachaf> `asm movq (%rax), %xmm0
2019-11-02 00:51:31 <HackEso> 0:  f3 0f 7e 00   movq (%rax),%xmm0
2019-11-02 00:51:36 <shachaf> `asm movq (%eax), %xmm0
2019-11-02 00:51:37 <HackEso> 0:  67 f3 0f 7e 00   movq (%eax),%xmm0
2019-11-02 00:53:11 <int-e> oh right, that was the gas syntax for these funny addressing modes
2019-11-02 00:53:38 <int-e> offset(%base,%index,multiplier)
2019-11-02 00:54:37 <olsner> possible dumb reason: someone planned/built a 32-bit x86 emulator (before compatibility mode was invented?) and convinced AMD to provide support for extra-stupid JIT compilers that just add prefixes to specific instructions
2019-11-02 00:55:35 <int-e> olsner: sorry, I lost track... reason for what?
2019-11-02 00:55:42 <olsner> for having the 32-bit override
2019-11-02 00:55:58 <int-e> ah.
2019-11-02 00:56:11 <int-e> plausible enough
2019-11-02 00:57:11 <int-e> I also bet this was rather cheap to support.
2019-11-02 00:58:16 <int-e> In context... which is a CPU that supports real mode (which has 32 bit addressing mode via the address size prefix) and 32 bit mode support for legacy software.
2019-11-02 01:01:07 <esowiki> 14[[07Esolang:Introduce yourself14]]4 10 02https://esolangs.org/w/index.php?diff=66918&oldid=66897 5* 03DmilkaSTD 5* (+179) 10/* Introductions */
2019-11-02 01:02:09 <esowiki> 14[[07Esomachine14]]4 N10 02https://esolangs.org/w/index.php?oldid=66919 5* 03DmilkaSTD 5* (+3608) 10Created page with "Esomachine was made by [https://esolangs.org/wiki/User:DmilkaSTD DmilkaSTD].  Imagine we have an array with infinite length. When it starts every array index is locked (If an..."
2019-11-02 01:09:20 <oerjan> congratulations, schlock. you might get to save the galaxy single-handed...
2019-11-02 01:17:39 Quit: arseniiv (Ping timeout: 246 seconds)
2019-11-02 01:17:39 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, oerjan, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 01:24:17 Quit: oerjan (Quit: Nite)
2019-11-02 01:24:17 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 01:25:33 Quit: imode (Ping timeout: 265 seconds)
2019-11-02 01:25:33 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 01:27:05 Joined: imode
2019-11-02 01:27:05 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 01:29:53 <shachaf> What other bizarro addressing modes are there in amd64?
2019-11-02 01:30:21 <shachaf> Also did I link this tcc SSE bug I found? https://lists.nongnu.org/archive/html/tinycc-devel/2019-10/msg00033.html
2019-11-02 01:30:30 <shachaf> It was somewhat annoying to track down.
2019-11-02 02:08:38 <kmc> what bizarro mode are you talking about
2019-11-02 02:08:58 <kmc> the base + mult*index + offset mode is pretty reasonable, aside from the gas syntax for it
2019-11-02 02:09:44 <kmc> with Intel syntax it'd be like  MOV EDI, DWORD PTR [4*EAX + EDX + 7]
2019-11-02 02:09:51 <kmc> or what have you
2019-11-02 02:09:53 <shachaf> Sure, but you have addr32, fs/gs, rip-relative, all sorts of things.
2019-11-02 02:10:50 <shachaf> Presumably there are some things I don't know about.
2019-11-02 02:11:10 <shachaf> Also there are all the little details, which I think I got right?
2019-11-02 02:11:36 <shachaf> `asm lea (%r11), %rax
2019-11-02 02:11:37 <HackEso> 0:  49 8d 03   lea (%r11),%rax
2019-11-02 02:11:38 <shachaf> `asm lea (%r12), %rax
2019-11-02 02:11:39 <HackEso> 0:  49 8d 04 24   lea (%r12),%rax
2019-11-02 02:11:57 Quit: imode (Ping timeout: 265 seconds)
2019-11-02 02:11:57 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 02:12:03 <shachaf> gotta include that sib byte for r12
2019-11-02 02:12:46 <shachaf> Of course I haven't done SSE/AVX/whatever at all, or the VEX prefix, or anything like that.
2019-11-02 02:14:25 <kmc> so much nonsense
2019-11-02 02:15:02 <shachaf> what instruction encoding are you into
2019-11-02 02:15:55 <fizzie> It doesn't even have a bit-reversed addressing mode.
2019-11-02 02:16:30 <shachaf> What's that?
2019-11-02 02:16:40 <fizzie> It's a thing DSPs have, for speeding up FFTs.
2019-11-02 02:16:59 <fizzie> The TI TMS320C54x at least has it.
2019-11-02 02:17:00 <shachaf> `asm lea (%r13), %rax
2019-11-02 02:17:01 <HackEso> 0:  49 8d 45 00   lea 0x0(%r13),%rax
2019-11-02 02:17:10 <shachaf> Right, r13 has a special case too.
2019-11-02 02:17:21 <kmc> oh?
2019-11-02 02:17:35 <shachaf> But I think that one is modrm+offset rather than modrm+SIB.
2019-11-02 02:17:44 <shachaf> fizzie: That sounds pretty fancy. I should learn about fancy DSP things.
2019-11-02 02:17:59 <fizzie> They also have circular addressing modes.
2019-11-02 02:18:06 <fizzie> For FIR filters and suchlike.
2019-11-02 02:18:47 <shachaf> Speaking of circles, what's the nicest way to write a circular buffer?
2019-11-02 02:18:56 <shachaf> I don't like having a boolean to distinguish empty from full.
2019-11-02 02:19:30 <fizzie> You can go with head + length instead of head + tail.
2019-11-02 02:19:43 <fizzie> Then you have 0 and N for empty and full.
2019-11-02 02:20:14 <shachaf> Hmm, I guess.
2019-11-02 02:20:23 <fizzie> There's also that one fancy thing that I think Chrome used somewhere, or someone used somewhere.
2019-11-02 02:20:25 <shachaf> What about the case where you have a separate reader and writer?
2019-11-02 02:20:33 <shachaf> I know of some other tricks:
2019-11-02 02:20:48 <shachaf> Map two copies of the same buffer in adjacent address space, so you get a contiguous buffer.
2019-11-02 02:20:52 <fizzie> The Bip-Buffer, that's what I was thinking of.
2019-11-02 02:21:01 <fizzie> The Bip-Buffer doesn't need the mapping trick.
2019-11-02 02:21:29 <fizzie> (On the other hand, it may waste some space.)
2019-11-02 02:22:30 <shachaf> Another trick I heard about is, instead of keeping the read/written size mod the buffer size, keep the total size, and mask it at use time.
2019-11-02 02:22:40 <kmc> bip booper
2019-11-02 02:24:48 <fizzie> I can't find any reference to anyone actually using the bip-buffer, just a few random implementations, so maybe I imagined that.
2019-11-02 02:25:06 <shachaf> I'm reading about it now.
2019-11-02 02:25:09 <fizzie> spsc-bip-buffer is "#108 in Concurrency" on lib.rs, which sounds like a TripAdvisor ranking.
2019-11-02 02:26:44 <shachaf> This explanation doesn't seem very clear.
2019-11-02 02:28:28 <shachaf> What's the benefit of this?
2019-11-02 02:28:49 <kmc> what is lib.rs
2019-11-02 02:28:59 <shachaf> Is it that writes are always contiguous (but reads might not be)?
2019-11-02 02:32:15 Joined: imode
2019-11-02 02:32:15 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 02:42:13 <fizzie> AIUI, the reads are contiguous too.
2019-11-02 02:43:40 <shachaf> Maybe I don't understand the diagram in https://www.codeproject.com/Articles/3479/The-Bip-Buffer-The-Circular-Buffer-with-a-Twist
2019-11-02 02:44:06 <shachaf> What happens in 5? From their description it looks like both A and B contain data.
2019-11-02 02:44:35 <fizzie> Right, reads of multiple writes are not necessarily contiguous.
2019-11-02 02:45:01 <fizzie> Maybe.
2019-11-02 02:45:13 <shachaf> Hmm.
2019-11-02 02:45:31 <shachaf> I guess the idea is that a library might want to write a fixed-size thing and you want to make sure to be able to fit it in the buffer?
2019-11-02 02:45:44 <shachaf> And another library can also interpret that fixed-size thing since it's contiguous.
2019-11-02 02:46:33 <shachaf> (Or, y'know, non-fixed-size.)
2019-11-02 02:46:38 <fizzie> Or, no, maybe reads of any size can be contiguous too, it's just that in stage 5 if you wanted to read more than the orange bit some copying would be involved.
2019-11-02 02:46:51 <fizzie> ...or maybe not.
2019-11-02 02:47:32 <shachaf> As in copying all the data in the buffer?
2019-11-02 02:47:37 <fizzie> Yeah, I was looking at the API, for reading you just ask the thing for the largest contiguous block.
2019-11-02 02:47:38 <shachaf> Regular circular buffers have this property too.
2019-11-02 02:47:44 <shachaf> Which API?
2019-11-02 02:48:05 <fizzie> Well, the BipBuffer class described there.
2019-11-02 02:48:21 <fizzie> But I guess it's still useful, if you (say) put length-delimited protos there.
2019-11-02 02:48:29 <shachaf> Oh, the one on that page.
2019-11-02 02:48:51 <shachaf> I guess that's true?
2019-11-02 02:48:56 <fizzie> As long as you write the thing into one contiguous (reserved) block, the reading side can also read it as one contiguous block.
2019-11-02 02:49:09 <shachaf> Right.
2019-11-02 02:49:24 <shachaf> Maybe it would be better for APIs to support reading and writing in multiple chunks.
2019-11-02 02:49:45 <fizzie> Maybe.
2019-11-02 02:49:46 <shachaf> I guess there's some concern that the API will want to keep an internal buffer and do some copying in order to support that.
2019-11-02 02:50:28 <shachaf> I think the mmap solution is better if you want things to be contiguous.
2019-11-02 03:04:51 Quit: imode (Ping timeout: 240 seconds)
2019-11-02 03:04:51 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 03:22:28 Joined: imode
2019-11-02 03:22:28 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 03:28:46 <int-e> @metar lowi
2019-11-02 03:28:47 <lambdabot> LOWI 020320Z AUTO 27011KT 9000 FEW001 BKN002 08/07 Q1006
2019-11-02 03:31:23 <shachaf> @metar koak
2019-11-02 03:31:23 <lambdabot> KOAK 020253Z 00000KT 10SM CLR 13/01 A3011 RMK AO2 SLP194 T01330011 53004
2019-11-02 04:17:47 User Name: imode = imode!~linear@unaffiliated/imode
2019-11-02 04:17:47 <imode> @metar ksea
2019-11-02 04:17:47 <lambdabot> KSEA 020353Z 01013KT 10SM SCT200 09/03 A3037 RMK AO2 SLP293 T00890033
2019-11-02 04:27:11 Joined: hppavilion[1]
2019-11-02 04:27:12 Names: \oren\, ^[, aji, aloril, APic, ArthurStrong, atslash, Bowserinator, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dog_star, economicsbat, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, GeekDude, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi1, heroux, Hooloovo0, howlands, hppavilion[1], imode, ineiros, int-e, interruptinuse, iovoid, j4cbo, jix, joast, kmc, lambdabot, LBPHacker, lf94, lifthrasiir, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, ornxka, OugiOshino, paul2520, pikhq, probability, ProofTechnique, quintopia, relrod, rodgort, Scrooge, sebbu, sftp, Sgeo, shachaf, shig, shikhin, ski, Soni, sparr, sprocklem, stux|away, subleq, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill
2019-11-02 04:32:45 <imode> using the thought I had earlier, you can build interesting data pipelines.
2019-11-02 04:33:14 <imode> sum $1234 bitvector
2019-11-02 04:33:45 <imode> or sum bitvector $1234 number
2019-11-02 04:34:30 <imode> because you push a handle to the concurrent process to the queue, any further processes can be constructed, passed that handle, and form a linear dataflow graph.
2019-11-02 04:35:46 <imode> a bidirectional one as well. `number` takes a number and a process to send that value to. `bitvector` takes a process, receives a number and sends the bits of that number to the taken process. `sum` takes a process, receives a number and keeps a running tally of that number which is available on request.
2019-11-02 04:35:55 <imode> you can do lazy evaluation with that.
2019-11-02 04:37:04 <imode> you can design a process that takes two handles, receives something and broadcasts it to the two processes it has handles to.
2019-11-02 05:01:36 <imode> https://hatebin.com/shiyqdhisf not bad.
2019-11-02 05:04:17 <imode> bitvector's logic is wrong, it should send zero on completion.
2019-11-02 05:07:42 <imode> https://hatebin.com/lriwwfiijo that's better.
2019-11-02 05:09:16 <imode> I feel like you can get pretty granular with this.
