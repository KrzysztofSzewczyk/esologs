2020-01-06 00:00:09 <b_jonas> it's a "new" thing, in the sense that it became used during the time I've been using linux
2020-01-06 00:01:17 <b_jonas> earlier we only had ordinary file systems backed on ramdisks, which are like flat virtual devices that are stored in the (virtual) memory, swappable, but then the kernel has to do most of the work that it would have to do to represent the file system on a (very fast) flat block device
2020-01-06 00:01:18 <zzo38> Specifically the data I want the external program to read is a blob in a SQLite database; maybe I should have mentioned that at first.
2020-01-06 00:01:29 <b_jonas> so tmpfs is more efficient
2020-01-06 00:01:49 <b_jonas> DOS also supports ramdisk
2020-01-06 00:02:38 <b_jonas> zzo38: but what does the program that you spawn do with its input and output?
2020-01-06 00:03:01 <zzo38> Converts it into a different format.
2020-01-06 00:03:33 <b_jonas> are the input and output very large? do you need interactivity, that is, do you want to get part of the output while you're still streaming the input?
2020-01-06 00:03:42 <b_jonas> and what do you do with the output?
2020-01-06 00:03:51 <zzo38> (And actually it isn't the entire blob; a few bytes at the beginning will be skipped, and this number may vary.)
2020-01-06 00:04:51 <zzo38> The input and output are potentially large, because it is a picture of the art in a card (e.g. the art box in a Magic: the Gathering card).
2020-01-06 00:04:55 <b_jonas> also is the sql database in a file that is slow to read, and do you want to be able to stop reading early in case of an error?
2020-01-06 00:05:16 <b_jonas> zzo38: just small vs large doesn't matter (unless it's so small that you just pass it in the argv), I'm asking if it can be very large
2020-01-06 00:05:36 <b_jonas> so it's not too large
2020-01-06 00:05:37 <zzo38> It might be very large if you are printing at a high resolution.
2020-01-06 00:06:19 <zzo38> The SQL database is already open by the main program (TeXnicard; maybe telling it is TeXnicard is also useful to you I don't know)
2020-01-06 00:07:17 <b_jonas> I'd probably just write the input data to a temporary regular file on a fast file system. if you can conveniently pass file descriptors to the program that you spawn, then unlink the file and pass just a file descriptor, that way if something goes wrong it's less likely that you have the temp file file remain on the disk.
2020-01-06 00:08:16 <b_jonas> you usually don't even need an actual tmpfs, if you don't have security requirements, because if everything fits in memory and you delete the file soon then the file won't leave the cache, and if it doesn't fit in memory then writing it out to the disk is a feature,
2020-01-06 00:08:48 <b_jonas> but if you have a fast swap device and no readily accessible file system on the fast device and no file system cache on the fast device, then you may want a tmpfs anyway
2020-01-06 00:08:55 <b_jonas> but that's not a common configuration these days
2020-01-06 00:09:56 <b_jonas> linux can now even handle the case when you store the file system on a slower rotating disk but cache it on a large SSD, because this is getting a commonly useful case
2020-01-06 00:10:10 <b_jonas> you have to configure it well, and I don't know the details, but I hear it's working well
2020-01-06 00:10:19 <zzo38> I didn't know it has that, but I thought of that too.
2020-01-06 00:10:52 <b_jonas> that need not be true if you're using old operating system software though, but then you likely won't have a fast SSD
2020-01-06 00:11:24 Quit: LKoen (Quit: “It’s only logical. First you learn to talk, then you learn to think. Too bad it’s not the other way round.”)
2020-01-06 00:11:24 Names: \oren\, ^[, aji, aloril, APic, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, ddmm, Deewiant, diginet, divergence, dnm, dog_star, eno1, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, heroux, Hooloovo0, howlands, imode, imode-ruby, int-e, interruptinuse, iovoid, izabera, j-bot, j4cbo, jix, joast, kingoffrance, kmc, laerling, lambdabot, LBPHacker, lifthrasiir, Lord_of_Life, Lykaina, Lymia, lynn, Melvar, mich181189, mniip, moony, myname, myndzi, nchambers, ocharles, olsner, ornxka, paul2520, pikhq, ProofTechnique, quintopia, relrod, rodgort, sebbu, sftp, Sgeo, shig, shikhin, shinh, Soni, sparr, sprocklem, stux, Taneb, trn, tromp, tswett[m], vertrex, wmww, zemhill, zoobab, zzo38
2020-01-06 00:11:36 <b_jonas> I don't really know what happens on Windows, I deliberately avoid all system administration responsibilities for Windows and don't want to learn more than I really need for my job
2020-01-06 00:11:57 <b_jonas> i.e. I don't work in system administration, but I need to administer my work desktop a bit to just use it for work
2020-01-06 00:12:31 <zzo38> I could write the data from the database to an external file and then pass that to the external program and then read back the output into memory, I suppose, since the output is likely to be larger than the input, but then that requires making a copy of the data
2020-01-06 00:12:53 <b_jonas> what will you do with the output?
2020-01-06 00:12:59 <b_jonas> will you send it to a printer?
2020-01-06 00:13:19 <b_jonas> or show it on the screen?
2020-01-06 00:15:14 <zzo38> It will be combined with an in-memory picture
2020-01-06 00:15:24 <b_jonas> I think this case hasn't come up for me, because I always just had the compressed image or video data stored in a disk file, and the raw data in memory going through a pipe
2020-01-06 00:16:37 <b_jonas> in one case the uncompressed data was also in a disk file, but in a format that I had to decode in my program (not sqlite specifically), but even then the other side, the compressed data went to disk files
2020-01-06 00:20:18 <zzo38> In my case the compressed data is in a SQLite database rather than a file by itself, and there should not be any need to store the uncompressed data in any file. The blob starts with a flag byte and then the MIME type (omitting "image/" if it belongs to that category, otherwise the full MIME type) and then the data in the format specified by the MIME type, and the configuration file specifies how to decode it.
2020-01-06 00:21:08 <b_jonas> and I presume the same database contains other metadata over just the images
2020-01-06 00:21:19 <b_jonas> which is why you don't just store the compressed image in a separate file
2020-01-06 00:23:24 <zzo38> Yes, that is true.
2020-01-06 00:23:56 <zzo38> And that is why it isn't stored in a separate file.
