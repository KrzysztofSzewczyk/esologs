2020-08-30 00:00:14 <b_jonas> which inner [] bind by reference
2020-08-30 00:00:15 <spruit11> I can always pass the vector -say- to itself as a field?
2020-08-30 00:00:23 <b_jonas> yes
2020-08-30 00:00:36 <b_jonas> but the vector isn't part of th DAG
2020-08-30 00:00:39 <b_jonas> it's separat
2020-08-30 00:00:52 <b_jonas> you just have a reference to vector that is a primitive type like a number
2020-08-30 00:00:53 <spruit11> Ah. Hmm.
2020-08-30 00:01:03 <b_jonas> that's what lisp does
2020-08-30 00:01:28 <b_jonas> and python and ruby etc
2020-08-30 00:01:47 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77106&oldid=77105 5* 03SoundOfScripting 5* (+468) 10/* Language specifications */
2020-08-30 00:01:54 <spruit11> All those languages allow cycles. Only early Lisp rewrote DAGs.
2020-08-30 00:02:10 <b_jonas> I don't think even early lisps did
2020-08-30 00:02:24 <spruit11> Yah, sure. The first one did. I read the report.
2020-08-30 00:02:25 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77107&oldid=77106 5* 03SoundOfScripting 5* (-1) 10
2020-08-30 00:03:28 <b_jonas> I think all serious lisps have set-car and set-cdr, even the oldest ones (possibly with a different name), but these days we want programs to not use it anywhere, so that conses are known to be globally immutable and the interpreter can optimize using that
2020-08-30 00:03:55 <b_jonas> and yes, some toy lisps might not have it, like my toy lisp for example
2020-08-30 00:04:13 <spruit11> Nono. The actual first Lisp was reference counted.
2020-08-30 00:04:32 <spruit11> By -whatshisname- McArthy. In the report.
2020-08-30 00:04:35 <b_jonas> yes
2020-08-30 00:04:46 <b_jonas> that doesn't stop this
2020-08-30 00:05:21 <b_jonas> you can just end up in uncollectable cycles if your program is not careful
2020-08-30 00:05:55 <b_jonas> but you can free a cycle either by breaking it, or using some newer data structure that allows weak referencing
2020-08-30 00:06:30 <spruit11> Right. My hope was that just being pure would cut it. But it's all way to slow. If it wasn't as slow as it is now, I wouldn't add vectors.
2020-08-30 00:06:48 <b_jonas> and it's John McCarthy (1927..2011)
2020-08-30 00:06:58 <spruit11> Ah right.
2020-08-30 00:07:03 <spruit11> McCarthy.
2020-08-30 00:07:37 <b_jonas> if you don't want mutability, you can consider lazy promises that you have to explicitly evaluae too
2020-08-30 00:07:53 <b_jonas> that solves a few of the problems, though not most
2020-08-30 00:08:18 <b_jonas> but if you want to keep immutability completely, you can also do that
2020-08-30 00:08:27 <spruit11> I would like to avoid mutability but it doesn't seem worth it.
2020-08-30 00:08:50 Joined: adu
2020-08-30 00:08:50 Names: ^[, adu, aloril, APic, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 00:09:00 <spruit11> In the sense that, I should give programmers mutable fast containers where they can't use lists.
2020-08-30 00:09:11 <spruit11> But that's assuming 'programmers'.
2020-08-30 00:09:13 <spruit11> Tall order.
2020-08-30 00:09:14 <b_jonas> I think it's worth in a non-toy language, but this is a toy language
2020-08-30 00:09:41 Joined: Arcorann
2020-08-30 00:09:41 Names: ^[, adu, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 00:09:47 <spruit11> Yah. But sometimes I flip opinion and hope it could be something like a bash or python.
2020-08-30 00:09:50 <b_jonas> sorry, that's conflicting
2020-08-30 00:09:58 <spruit11> And then I think: nah.
2020-08-30 00:10:02 <b_jonas> I think it's worth *to adds mutable structures* in a non-toy language, but this is a toy language
2020-08-30 00:10:12 <spruit11> And then I flip opinion again.
2020-08-30 00:10:25 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77108&oldid=77107 5* 03SoundOfScripting 5* (+341) 10/* Language specifications */ More instructions :)
2020-08-30 00:11:44 <b_jonas> I admit that olvashato doesn't have mutability, because I didn't want them for the programs I wrote, but you could add them in a library
2020-08-30 00:11:59 <b_jonas> it's a bit messy because of the prolog side, but possible
2020-08-30 00:12:25 <spruit11> Today I wanted to compare my abysmal performance to Python.
2020-08-30 00:12:43 <b_jonas> my toy lisp does have mutability
2020-08-30 00:12:48 <spruit11> Which gave an out of stack after going 900 deep into recursion.
2020-08-30 00:13:00 <b_jonas> heh
2020-08-30 00:13:03 <spruit11> So then I thought: maybe there's a use case after all.
2020-08-30 00:13:13 <spruit11> And now I think: nah.
2020-08-30 00:13:37 <spruit11> ¯\_(ツ)_/¯
2020-08-30 00:13:48 <Heavpoot> what if esolang where computations have to be done with constantly changing operator precedence, and said operators modify precedence?
2020-08-30 00:27:44 <spruit11> I could add explicitly managed vectors. Where you indirectly reference a vector pool with an index. And you're responsible for managing memory.
2020-08-30 00:28:45 <spruit11> But if you're managing memory already you might as well make sure that your vector doesn't contain cycles.
2020-08-30 00:29:11 <spruit11> Ah well. Gonna hack on the double semicolon, I think.
2020-08-30 00:29:55 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77109&oldid=77108 5* 03SoundOfScripting 5* (+78) 10
2020-08-30 00:30:07 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77110&oldid=77109 5* 03IFcoltransG 5* (+9) 10/* Language specifications */ Commented out unnecessary section
2020-08-30 00:32:22 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77111&oldid=77110 5* 03SoundOfScripting 5* (+3) 10
2020-08-30 00:33:22 <b_jonas> spruit11: by "explicitly managed", do you mean that the user has to free them explicitly, they're not refcounted or tracked by the refcounter or garbage collector that handles your DAG nodes?
2020-08-30 00:33:47 <b_jonas> to be clear, all that mutability stuff is less important than what I mentioned earlier
2020-08-30 00:34:11 <spruit11> Right. You reference a vector indirectly in a pool. That way you break the cycle. But the cost for that is also that you would need to free it.
2020-08-30 00:34:35 <b_jonas> hmm, that would be much more inconvenient
2020-08-30 00:34:51 <b_jonas> I was thinking it would at least be refcounted
2020-08-30 00:35:12 <spruit11> Yah. Doesn't seem worth it.
2020-08-30 00:35:31 <spruit11> Oh.
2020-08-30 00:35:35 <spruit11> Wait.
2020-08-30 00:35:56 <spruit11> I could free it if the reference is destroyed?
2020-08-30 00:36:01 <spruit11> What voodoo is this?
2020-08-30 00:36:12 <b_jonas> that is the voodoo of recounting
2020-08-30 00:36:36 <b_jonas> I mean don't you already have something like that for the DAG nodes?
2020-08-30 00:37:23 <spruit11> Uh. I abuse C++'s native refcounting.
2020-08-30 00:38:36 <b_jonas> C++'s "native refcounting"? what do you mean? do you mean std::shared_ptr, which is a reference-counted smart pointer type?
2020-08-30 00:38:42 <spruit11> Yah.
2020-08-30 00:38:49 <b_jonas> why is that an abuse?
2020-08-30 00:39:00 <b_jonas> you can use that for the vectors too
2020-08-30 00:39:35 <spruit11> Uh, yes and no.
2020-08-30 00:40:05 <spruit11> I need a form of indirection over a vector pool. But that's all yes.
2020-08-30 00:40:40 <b_jonas> I don't see why it's an abuse, and I'm not sure in what sense it counts as "native", but then that's because I remember the past when that wasn't in the standard library yet, and also I know it's implemented as a pure library feature
2020-08-30 00:41:02 <b_jonas> um... vector pool?
2020-08-30 00:41:48 <b_jonas> what why?
2020-08-30 00:42:04 <spruit11> Well. The thing is that in the 'graph' you construct you don't want cycles. But if a 'vector' object only stores an index into a global vector pool, you can't create cycles.
2020-08-30 00:42:49 <b_jonas> sure you can, if it's reference-counted both ways, as in the vector keeps alive the dag node it points to and the dag node keeps alive the vector it points to, then it can form cycles
2020-08-30 00:42:56 <b_jonas> it doesn't matter if you allocate them from a pool or not
2020-08-30 00:43:23 <spruit11> Damn.
2020-08-30 00:43:35 <spruit11> Right.
2020-08-30 00:43:49 <spruit11> No vector pool than but unsafeness.
2020-08-30 00:44:00 <b_jonas> why? what's unsafe in this?
2020-08-30 00:44:02 <spruit11> Thanks for that. For a moment I thought I found a way out.
2020-08-30 00:44:28 <b_jonas> make it reference-counted both ways, and document that it's only reference counted so if you leave a cycle it won't be collected and that that's the user's responsibility
2020-08-30 00:44:32 <spruit11> The unsafe part is that I would allow the programmer to form cycles in what should be a DAG.
2020-08-30 00:44:52 <spruit11> Right. We agree.
2020-08-30 00:46:04 <b_jonas> but it's not a cycle that will bother the pattern matcher or the pretty-printer or anything, because the pattern matcher doesn't go arbitrarily deep through vectors because there's no such pattern, and you can just make the pretty-printer either not print the contents of vectors at all, only a reference, like it doesn't print the content of a function now, or make it track which vector it met and not
2020-08-30 00:46:10 <b_jonas> print repeated vectors
2020-08-30 00:46:24 <b_jonas> so I don't see why the cycles are a problem
2020-08-30 00:47:09 <b_jonas> unless this is like your PhD thesis and you have "DAG" prominently in the plan you submitted and now you have to resubmit the plan and wait for permission from a committee to be allowed to write non-DAGs
2020-08-30 00:47:12 <spruit11> I think I fully agree with you.
2020-08-30 00:47:41 <spruit11> Nono. If I would be doing a PhD I would already been kicked out for not having a type system.
2020-08-30 00:49:09 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77112&oldid=77111 5* 03IFcoltransG 5* (+875) 10/* Language specifications */ Add oculi for converting between bits and bytes
2020-08-30 00:49:52 <b_jonas> well, technically there's another case when you don't want this: if you want to make a sandbox version of egel to run untrusted code by multiple users (like a javascript interpreter in an old browser that runs everything in one procesS), and want to be able to free every object created by a user by just freeing a few top-level references, in which case you need either a garbage collector, or allocate
2020-08-30 00:49:58 <b_jonas> everything into arenas, different users never share an arena, and free each arena owned by a user when you're done with them
2020-08-30 00:50:09 <b_jonas> but you would need a lot of other changes too if you wanted that
2020-08-30 00:50:53 <spruit11> Life is never easy.
2020-08-30 00:51:34 <spruit11> I already regret compiling to bytecode. And I also regret having a global pool for recursive structures.
2020-08-30 00:51:53 <spruit11> Life would be so much nicer without those two.
2020-08-30 00:52:10 <b_jonas> spruit11: ah yes, that's when you make an incompatible egel2
2020-08-30 00:52:25 <b_jonas> where you keep the ideas you like and redesigne and rewrite everything
2020-08-30 00:53:36 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77113&oldid=77112 5* 03IFcoltransG 5* (+291) 10Clarified Tokigun's half cell movements
2020-08-30 00:53:44 <spruit11> Hmyah. I'll end up with a toy of a toy.
2020-08-30 00:53:49 <spruit11> A noble cause!
2020-08-30 00:54:27 <spruit11> Anyway, you got me fired up. I am hacking on the double semicolon now.
2020-08-30 00:54:37 <b_jonas> nice
2020-08-30 00:59:46 <fizzie> Isn't a double semicolon just one whole colon?
