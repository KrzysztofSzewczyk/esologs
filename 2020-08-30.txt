2020-08-30 00:00:14 <b_jonas> which inner [] bind by reference
2020-08-30 00:00:15 <spruit11> I can always pass the vector -say- to itself as a field?
2020-08-30 00:00:23 <b_jonas> yes
2020-08-30 00:00:36 <b_jonas> but the vector isn't part of th DAG
2020-08-30 00:00:39 <b_jonas> it's separat
2020-08-30 00:00:52 <b_jonas> you just have a reference to vector that is a primitive type like a number
2020-08-30 00:00:53 <spruit11> Ah. Hmm.
2020-08-30 00:01:03 <b_jonas> that's what lisp does
2020-08-30 00:01:28 <b_jonas> and python and ruby etc
2020-08-30 00:01:47 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77106&oldid=77105 5* 03SoundOfScripting 5* (+468) 10/* Language specifications */
2020-08-30 00:01:54 <spruit11> All those languages allow cycles. Only early Lisp rewrote DAGs.
2020-08-30 00:02:10 <b_jonas> I don't think even early lisps did
2020-08-30 00:02:24 <spruit11> Yah, sure. The first one did. I read the report.
2020-08-30 00:02:25 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77107&oldid=77106 5* 03SoundOfScripting 5* (-1) 10
2020-08-30 00:03:28 <b_jonas> I think all serious lisps have set-car and set-cdr, even the oldest ones (possibly with a different name), but these days we want programs to not use it anywhere, so that conses are known to be globally immutable and the interpreter can optimize using that
2020-08-30 00:03:55 <b_jonas> and yes, some toy lisps might not have it, like my toy lisp for example
2020-08-30 00:04:13 <spruit11> Nono. The actual first Lisp was reference counted.
2020-08-30 00:04:32 <spruit11> By -whatshisname- McArthy. In the report.
2020-08-30 00:04:35 <b_jonas> yes
2020-08-30 00:04:46 <b_jonas> that doesn't stop this
2020-08-30 00:05:21 <b_jonas> you can just end up in uncollectable cycles if your program is not careful
2020-08-30 00:05:55 <b_jonas> but you can free a cycle either by breaking it, or using some newer data structure that allows weak referencing
2020-08-30 00:06:30 <spruit11> Right. My hope was that just being pure would cut it. But it's all way to slow. If it wasn't as slow as it is now, I wouldn't add vectors.
2020-08-30 00:06:48 <b_jonas> and it's John McCarthy (1927..2011)
2020-08-30 00:06:58 <spruit11> Ah right.
2020-08-30 00:07:03 <spruit11> McCarthy.
2020-08-30 00:07:37 <b_jonas> if you don't want mutability, you can consider lazy promises that you have to explicitly evaluae too
2020-08-30 00:07:53 <b_jonas> that solves a few of the problems, though not most
2020-08-30 00:08:18 <b_jonas> but if you want to keep immutability completely, you can also do that
2020-08-30 00:08:27 <spruit11> I would like to avoid mutability but it doesn't seem worth it.
2020-08-30 00:08:50 Joined: adu
2020-08-30 00:08:50 Names: ^[, adu, aloril, APic, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 00:09:00 <spruit11> In the sense that, I should give programmers mutable fast containers where they can't use lists.
2020-08-30 00:09:11 <spruit11> But that's assuming 'programmers'.
2020-08-30 00:09:13 <spruit11> Tall order.
2020-08-30 00:09:14 <b_jonas> I think it's worth in a non-toy language, but this is a toy language
2020-08-30 00:09:41 Joined: Arcorann
2020-08-30 00:09:41 Names: ^[, adu, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 00:09:47 <spruit11> Yah. But sometimes I flip opinion and hope it could be something like a bash or python.
2020-08-30 00:09:50 <b_jonas> sorry, that's conflicting
2020-08-30 00:09:58 <spruit11> And then I think: nah.
2020-08-30 00:10:02 <b_jonas> I think it's worth *to adds mutable structures* in a non-toy language, but this is a toy language
2020-08-30 00:10:12 <spruit11> And then I flip opinion again.
2020-08-30 00:10:25 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77108&oldid=77107 5* 03SoundOfScripting 5* (+341) 10/* Language specifications */ More instructions :)
2020-08-30 00:11:44 <b_jonas> I admit that olvashato doesn't have mutability, because I didn't want them for the programs I wrote, but you could add them in a library
2020-08-30 00:11:59 <b_jonas> it's a bit messy because of the prolog side, but possible
2020-08-30 00:12:25 <spruit11> Today I wanted to compare my abysmal performance to Python.
2020-08-30 00:12:43 <b_jonas> my toy lisp does have mutability
2020-08-30 00:12:48 <spruit11> Which gave an out of stack after going 900 deep into recursion.
2020-08-30 00:13:00 <b_jonas> heh
2020-08-30 00:13:03 <spruit11> So then I thought: maybe there's a use case after all.
2020-08-30 00:13:13 <spruit11> And now I think: nah.
2020-08-30 00:13:37 <spruit11> ¯\_(ツ)_/¯
2020-08-30 00:13:48 <Heavpoot> what if esolang where computations have to be done with constantly changing operator precedence, and said operators modify precedence?
2020-08-30 00:27:44 <spruit11> I could add explicitly managed vectors. Where you indirectly reference a vector pool with an index. And you're responsible for managing memory.
2020-08-30 00:28:45 <spruit11> But if you're managing memory already you might as well make sure that your vector doesn't contain cycles.
2020-08-30 00:29:11 <spruit11> Ah well. Gonna hack on the double semicolon, I think.
2020-08-30 00:29:55 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77109&oldid=77108 5* 03SoundOfScripting 5* (+78) 10
2020-08-30 00:30:07 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77110&oldid=77109 5* 03IFcoltransG 5* (+9) 10/* Language specifications */ Commented out unnecessary section
2020-08-30 00:32:22 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77111&oldid=77110 5* 03SoundOfScripting 5* (+3) 10
2020-08-30 00:33:22 <b_jonas> spruit11: by "explicitly managed", do you mean that the user has to free them explicitly, they're not refcounted or tracked by the refcounter or garbage collector that handles your DAG nodes?
2020-08-30 00:33:47 <b_jonas> to be clear, all that mutability stuff is less important than what I mentioned earlier
2020-08-30 00:34:11 <spruit11> Right. You reference a vector indirectly in a pool. That way you break the cycle. But the cost for that is also that you would need to free it.
2020-08-30 00:34:35 <b_jonas> hmm, that would be much more inconvenient
2020-08-30 00:34:51 <b_jonas> I was thinking it would at least be refcounted
2020-08-30 00:35:12 <spruit11> Yah. Doesn't seem worth it.
2020-08-30 00:35:31 <spruit11> Oh.
2020-08-30 00:35:35 <spruit11> Wait.
2020-08-30 00:35:56 <spruit11> I could free it if the reference is destroyed?
2020-08-30 00:36:01 <spruit11> What voodoo is this?
2020-08-30 00:36:12 <b_jonas> that is the voodoo of recounting
2020-08-30 00:36:36 <b_jonas> I mean don't you already have something like that for the DAG nodes?
2020-08-30 00:37:23 <spruit11> Uh. I abuse C++'s native refcounting.
2020-08-30 00:38:36 <b_jonas> C++'s "native refcounting"? what do you mean? do you mean std::shared_ptr, which is a reference-counted smart pointer type?
2020-08-30 00:38:42 <spruit11> Yah.
2020-08-30 00:38:49 <b_jonas> why is that an abuse?
2020-08-30 00:39:00 <b_jonas> you can use that for the vectors too
2020-08-30 00:39:35 <spruit11> Uh, yes and no.
2020-08-30 00:40:05 <spruit11> I need a form of indirection over a vector pool. But that's all yes.
2020-08-30 00:40:40 <b_jonas> I don't see why it's an abuse, and I'm not sure in what sense it counts as "native", but then that's because I remember the past when that wasn't in the standard library yet, and also I know it's implemented as a pure library feature
2020-08-30 00:41:02 <b_jonas> um... vector pool?
2020-08-30 00:41:48 <b_jonas> what why?
2020-08-30 00:42:04 <spruit11> Well. The thing is that in the 'graph' you construct you don't want cycles. But if a 'vector' object only stores an index into a global vector pool, you can't create cycles.
2020-08-30 00:42:49 <b_jonas> sure you can, if it's reference-counted both ways, as in the vector keeps alive the dag node it points to and the dag node keeps alive the vector it points to, then it can form cycles
2020-08-30 00:42:56 <b_jonas> it doesn't matter if you allocate them from a pool or not
2020-08-30 00:43:23 <spruit11> Damn.
2020-08-30 00:43:35 <spruit11> Right.
2020-08-30 00:43:49 <spruit11> No vector pool than but unsafeness.
2020-08-30 00:44:00 <b_jonas> why? what's unsafe in this?
2020-08-30 00:44:02 <spruit11> Thanks for that. For a moment I thought I found a way out.
2020-08-30 00:44:28 <b_jonas> make it reference-counted both ways, and document that it's only reference counted so if you leave a cycle it won't be collected and that that's the user's responsibility
2020-08-30 00:44:32 <spruit11> The unsafe part is that I would allow the programmer to form cycles in what should be a DAG.
2020-08-30 00:44:52 <spruit11> Right. We agree.
2020-08-30 00:46:04 <b_jonas> but it's not a cycle that will bother the pattern matcher or the pretty-printer or anything, because the pattern matcher doesn't go arbitrarily deep through vectors because there's no such pattern, and you can just make the pretty-printer either not print the contents of vectors at all, only a reference, like it doesn't print the content of a function now, or make it track which vector it met and not
2020-08-30 00:46:10 <b_jonas> print repeated vectors
2020-08-30 00:46:24 <b_jonas> so I don't see why the cycles are a problem
2020-08-30 00:47:09 <b_jonas> unless this is like your PhD thesis and you have "DAG" prominently in the plan you submitted and now you have to resubmit the plan and wait for permission from a committee to be allowed to write non-DAGs
2020-08-30 00:47:12 <spruit11> I think I fully agree with you.
2020-08-30 00:47:41 <spruit11> Nono. If I would be doing a PhD I would already been kicked out for not having a type system.
2020-08-30 00:49:09 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77112&oldid=77111 5* 03IFcoltransG 5* (+875) 10/* Language specifications */ Add oculi for converting between bits and bytes
2020-08-30 00:49:52 <b_jonas> well, technically there's another case when you don't want this: if you want to make a sandbox version of egel to run untrusted code by multiple users (like a javascript interpreter in an old browser that runs everything in one procesS), and want to be able to free every object created by a user by just freeing a few top-level references, in which case you need either a garbage collector, or allocate
2020-08-30 00:49:58 <b_jonas> everything into arenas, different users never share an arena, and free each arena owned by a user when you're done with them
2020-08-30 00:50:09 <b_jonas> but you would need a lot of other changes too if you wanted that
2020-08-30 00:50:53 <spruit11> Life is never easy.
2020-08-30 00:51:34 <spruit11> I already regret compiling to bytecode. And I also regret having a global pool for recursive structures.
2020-08-30 00:51:53 <spruit11> Life would be so much nicer without those two.
2020-08-30 00:52:10 <b_jonas> spruit11: ah yes, that's when you make an incompatible egel2
2020-08-30 00:52:25 <b_jonas> where you keep the ideas you like and redesigne and rewrite everything
2020-08-30 00:53:36 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77113&oldid=77112 5* 03IFcoltransG 5* (+291) 10Clarified Tokigun's half cell movements
2020-08-30 00:53:44 <spruit11> Hmyah. I'll end up with a toy of a toy.
2020-08-30 00:53:49 <spruit11> A noble cause!
2020-08-30 00:54:27 <spruit11> Anyway, you got me fired up. I am hacking on the double semicolon now.
2020-08-30 00:54:37 <b_jonas> nice
2020-08-30 00:59:46 <fizzie> Isn't a double semicolon just one whole colon?
2020-08-30 01:00:37 <b_jonas> fizzie: no, because English sucks
2020-08-30 01:00:48 <b_jonas> but good point
2020-08-30 01:02:11 <b_jonas> spruit11: also, if you do a major rewrite where you keep some code and rewrite some of it, you will need to learn branching in version control
2020-08-30 01:06:17 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77114&oldid=77113 5* 03IFcoltransG 5* (+273) 10/* Language specifications */ Added equality check command
2020-08-30 01:19:02 <zzo38> I have not used branched version control so far, but that would probably be one case where it could be used.
2020-08-30 01:23:52 Joined: egelbot
2020-08-30 01:23:52 Names: ^[, adu, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, egelbot, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 01:24:14 <spruit11> egelbot: using System;; 1+1;; 2+2
2020-08-30 01:24:14 User Name: egelbot = egelbot!~egelbot@86-82-44-193.fixed.kpn.net
2020-08-30 01:24:14 <egelbot> 2
2020-08-30 01:24:14 <egelbot> 4
2020-08-30 01:30:22 <spruit11> egelbot: using String;; strlen "hello"
2020-08-30 01:30:22 <egelbot> 5
2020-08-30 01:31:06 <spruit11> Well, that takes care of that.
2020-08-30 01:32:51 Quit: adu (Quit: adu)
2020-08-30 01:32:52 Names: ^[, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, egelbot, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, Heavpoot, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 01:38:44 <spruit11> egelbot: getenv "EGEL_PS0"
2020-08-30 01:39:21 <spruit11> egelbot: getenv "PATH"
2020-08-30 01:39:21 <egelbot> "/home/marco/.local/bin:/home/marco/bin:/usr/share/Modules/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin"
2020-08-30 01:39:51 <spruit11> Weird path.
2020-08-30 01:39:58 <spruit11> Ah well.
2020-08-30 01:44:52 <b_jonas> spruit11: nice, that was quick
2020-08-30 01:45:15 <spruit11> Yah, it was painless.
2020-08-30 01:47:42 <b_jonas> egelbot: 3+3
2020-08-30 01:47:42 <egelbot> 6
2020-08-30 01:47:53 <b_jonas> egelbot: getenv "HOME"
2020-08-30 01:47:53 <egelbot> "/home/marco"
2020-08-30 01:48:00 <b_jonas> egelbot: getenv "DISPLAY"
2020-08-30 01:48:00 <egelbot> ":0"
2020-08-30 01:48:09 <spruit11> Hey!
2020-08-30 01:48:09 <b_jonas> egelbot: getenv "LANG"
2020-08-30 01:48:09 <egelbot> "en_US.UTF-8"
2020-08-30 01:48:17 <b_jonas> egelbot: getenv "LC_ALL"
2020-08-30 01:48:45 <b_jonas> egelbot: {getenv "USER", getenv "TERM", getenv "LC_ALL"}
2020-08-30 01:48:45 <egelbot> (System:cons "marco" (System:cons "xterm-256color" (System:cons System:nop System:nil)))
2020-08-30 01:49:36 <b_jonas> egelbot: (getenv "_",)
2020-08-30 01:49:36 <egelbot> internal:1:14:syntactical:primary expression expected
2020-08-30 01:49:43 <b_jonas> egelbot: tuple (getenv "_")
2020-08-30 01:49:43 <egelbot> (System:tuple "./egel-bot")
2020-08-30 01:50:43 <spruit11> egelbot: using Math;; sin 1.0
2020-08-30 01:50:43 <egelbot> 0.8414709848078965
2020-08-30 01:51:55 <b_jonas> egelbot: data foo;; let bar = [X -> 2];; foo;; bar foo
2020-08-30 01:51:55 <egelbot> internal:1:31:syntactical:in expected
2020-08-30 01:52:02 <spruit11> def
2020-08-30 01:52:10 <b_jonas> egelbot: data foo;; var bar = [X -> 2];; foo;; bar foo
2020-08-30 01:52:10 <egelbot> internal:1:21:syntactical:= unexpected
2020-08-30 01:52:16 <b_jonas> egelbot: data foo;; def bar = [X -> 2];; foo;; bar foo
2020-08-30 01:52:16 <egelbot> foo
2020-08-30 01:52:16 <egelbot> 2
2020-08-30 01:52:37 <b_jonas> egelbot: data foo;; def bar = [X -> 2];; bar foo;; quux
2020-08-30 01:52:37 <egelbot> 2
2020-08-30 01:52:37 <egelbot> internal:1:44:semantical:undeclared quux
2020-08-30 01:52:52 <b_jonas> egelbot: data foo;; def bar = [X -> 2];; quux;; bar
2020-08-30 01:52:52 <egelbot> internal:1:34:semantical:undeclared quux
2020-08-30 01:53:01 <b_jonas> egelbot: bar
2020-08-30 01:53:01 <egelbot> bar
2020-08-30 01:53:04 <b_jonas> egelbot: bar foo
2020-08-30 01:53:04 <egelbot> 2
2020-08-30 01:53:13 <b_jonas> right
2020-08-30 01:53:49 <spruit11> egelbot: val id = [ X -> X ];; val one = 1;; id one
2020-08-30 01:53:49 <egelbot> 1
2020-08-30 01:54:00 <spruit11> Okay, that works too.
2020-08-30 01:54:28 <b_jonas> egelbot: data foo;; def foo0 = foo;; data foo;; def isfoo = [foo -> true | _ -> false];; (foo0, foo, isfoo foo0, isfoo foo)
2020-08-30 01:54:28 <egelbot> (System:tuple foo foo System:true System:true)
2020-08-30 01:54:36 <b_jonas> hmm
2020-08-30 01:54:44 <b_jonas> egelbot: data foo;; def foo0 = foo;;
2020-08-30 01:54:44 <egelbot> internal:1:30:syntactical:primary expression expected
2020-08-30 01:54:49 <b_jonas> egelbot: data foo;; def foo0 = foo;; 1
2020-08-30 01:54:49 <egelbot> 1
2020-08-30 01:55:04 <b_jonas> egelbot: data foo;; 2
2020-08-30 01:55:04 <egelbot> 2
2020-08-30 01:55:10 <b_jonas> egelbot: def isfoo = [foo -> true | _ -> false];; (foo0, foo, isfoo foo0, isfoo foo)
2020-08-30 01:55:10 <egelbot> (System:tuple foo foo System:true System:true)
2020-08-30 01:55:14 <b_jonas> still true
2020-08-30 01:55:26 <b_jonas> egelbot: def foo = 5; data foo;; 2
2020-08-30 01:55:26 <egelbot> internal:1:15:syntactical:primary expression expected
2020-08-30 01:55:31 <b_jonas> egelbot: def foo = 5;; data foo;; 2
2020-08-30 01:55:31 <egelbot> 2
2020-08-30 01:55:34 <b_jonas> egelbot: def isfoo = [foo -> true | _ -> false];; (foo0, foo, isfoo foo0, isfoo foo)
2020-08-30 01:55:34 <egelbot> (System:tuple foo foo System:true System:true)
2020-08-30 01:55:38 <b_jonas> egelbot: def foo = 5;;
2020-08-30 01:55:38 <egelbot> internal:1:16:syntactical:primary expression expected
2020-08-30 01:55:42 <b_jonas> egelbot: def foo = 5;; foo
2020-08-30 01:55:42 <egelbot> 5
2020-08-30 01:55:44 <b_jonas> egelbot: def isfoo = [foo -> true | _ -> false];; (foo0, foo, isfoo foo0, isfoo foo)
2020-08-30 01:55:44 <egelbot> (System:tuple 5 5 System:false System:false)
2020-08-30 01:55:48 <b_jonas> what
2020-08-30 01:56:12 <spruit11> foo = 5
2020-08-30 01:56:18 <b_jonas> yes
2020-08-30 01:56:38 <spruit11> So isfoo reduces to false.
2020-08-30 01:56:39 <b_jonas> but I thought foo0 still has the binding to the old foo, which is a different foo even if its name is the same
2020-08-30 01:56:48 <spruit11> No.
2020-08-30 01:57:11 <b_jonas> oh well
2020-08-30 01:57:16 <spruit11> One global table for definitions you can interactively modify.
2020-08-30 01:57:30 <b_jonas> and anything lowercase refers to that?
2020-08-30 01:57:31 <b_jonas> ok
2020-08-30 01:57:45 <b_jonas> I mean they're resolved late, even when they're already in a definition?
2020-08-30 01:57:53 <b_jonas> egelbot: def isfoo = [foo -> true | _ -> false];;
2020-08-30 01:57:53 <egelbot> internal:1:43:syntactical:primary expression expected
2020-08-30 01:57:56 <spruit11> Yah.
2020-08-30 01:58:00 <b_jonas> egelbot: data foo
2020-08-30 01:58:07 <b_jonas> egelbot: def isfoo = [foo -> true | _ -> false]
2020-08-30 01:58:10 <b_jonas> egelbot: isfoo
2020-08-30 01:58:10 <egelbot> isfoo
2020-08-30 01:58:16 <b_jonas> egelbot: def Isfoo = [foo -> true | _ -> false]
2020-08-30 01:58:16 <egelbot> internal:1:2:syntactical:combinator or operator expected
2020-08-30 01:58:30 <b_jonas> egelbot: data foo
2020-08-30 01:58:34 <b_jonas> egelbot: isfoo foo
2020-08-30 01:58:34 <egelbot> System:true
2020-08-30 01:58:54 <b_jonas> so isfoo has a definition that refers to foo by name and dynamically resolves it
2020-08-30 01:58:57 <b_jonas> ok
2020-08-30 01:59:09 <spruit11> Combinators lowercase, variables uppercase. It was the only thing which I thought made sense in an untyped environment.
2020-08-30 01:59:47 <b_jonas> yeah, it's like prolog I guess
2020-08-30 01:59:56 <spruit11> The problem is [ x -> x ], I need/want to know whether x is a variable of combinator.
2020-08-30 02:00:05 <b_jonas> except for, you know, the implicit unevaluated function thing
2020-08-30 02:00:16 <spruit11> Yah, Prolog chose the solution.
2020-08-30 02:00:46 <spruit11> Well, Prolog is another operational model. This is just a broken down FP.
2020-08-30 02:01:09 <b_jonas> this is not the syntax I like too much, but it works and is consistent
2020-08-30 02:01:09 <spruit11> *the same solution.
2020-08-30 02:02:00 <spruit11> Yah. But `[x -> x]` right? In a typed environment you can check whether it binds correctly to a combinator or otherwise should bind to a variable.
2020-08-30 02:03:29 <b_jonas> I would suggest no case difference, in a pattern if a name stands alone rather than as the head of an application then it's a freshly bound variable, there's some way to disambiguate it to a constructor (with an empty parenthesis when you use parenthesis function calls, or with a namespace prefix), and a few important nullary constructors (eg. true, false, just, unit) are keywords
2020-08-30 02:03:37 <spruit11> Making the distinction up front means you can visually see the difference, and simplifies the interpreter (which otherwise would need heuristics).
2020-08-30 02:04:09 <b_jonas> but it might not work well in egel because application doesn't use parens, so you can't use an empty paren
2020-08-30 02:04:21 <spruit11> No. But Egel is untyped. You can have a variable in the head.
2020-08-30 02:04:44 <spruit11> egelbot: [ (X Y Z) -> Z Y X ] {1}
2020-08-30 02:04:44 <egelbot> (System:nil 1 System:cons)
2020-08-30 02:05:24 <spruit11> And for orthogonality I want to keep that.
2020-08-30 02:05:37 <b_jonas> and constructors are not namespaced under enum typenames, so you don't have a convenient namespace syntax that you can use to name any constructor already
2020-08-30 02:05:52 <b_jonas> spruit11: yeah, egel does that unevaluated thing, so this wouldn't work
2020-08-30 02:07:13 <spruit11> No. It's weird stemming from Haskell/OCaml but if you see Egel as an LC+constants it's the only thing which makes sense.
2020-08-30 02:07:22 <spruit11> (lambda calculus)
2020-08-30 02:07:34 <esowiki> 14[[07User:Hakerh40014]]4 10 02https://esolangs.org/w/index.php?diff=77115&oldid=76891 5* 03Hakerh400 5* (+24) 10
2020-08-30 02:08:43 <esowiki> 14[[07User:Hakerh40014]]4 10 02https://esolangs.org/w/index.php?diff=77116&oldid=77115 5* 03Hakerh400 5* (-20) 10
2020-08-30 02:09:44 <spruit11> Right, in an untyped LC+constants `1 2` is a term and you want to be able to pattern match on that.
2020-08-30 02:10:29 <b_jonas> spruit11: no, only if you allow unevaluted applications
2020-08-30 02:10:45 <spruit11> I don't see that?
2020-08-30 02:10:48 <b_jonas> normally `1 2` would try to call the function `1` which is an error because it's not a function
2020-08-30 02:11:11 <b_jonas> but in spruit you allow any application and they just default to unevaluated
2020-08-30 02:11:16 <spruit11> It's normally allowed by the grammar...
2020-08-30 02:11:25 <b_jonas> it's not the grammar
2020-08-30 02:11:45 <b_jonas> you could write (1 2) in the code, and it wouldn't even give an error until you try to evaluate it
2020-08-30 02:11:48 <spruit11> T := V | C | T T | \V. T
2020-08-30 02:12:05 <b_jonas> but if you want to pattern match to something, then it has to try to evaluate it, fully in an eager language, or to top level constructor in a lazy language
2020-08-30 02:12:08 <b_jonas> like haskell
2020-08-30 02:12:22 <spruit11> Okay. Then I just difer on what I consider an untyped LC+constants.
2020-08-30 02:12:28 <b_jonas> yeah
2020-08-30 02:12:29 <spruit11> *differ
2020-08-30 02:17:36 <esowiki> 14[[07Special:Log/newusers14]]4 create10 02 5* 03R123124 5*  10New user account
2020-08-30 02:17:44 Quit: Heavpoot (Remote host closed the connection)
2020-08-30 02:17:44 Names: ^[, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, egelbot, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 02:21:06 <esowiki> 14[[07Esolang:Introduce yourself14]]4 10 02https://esolangs.org/w/index.php?diff=77117&oldid=76916 5* 03R123124 5* (+108) 10/* Introductions */
2020-08-30 03:32:30 <esowiki> 14[[07Special:Log/upload14]]4 upload10 02 5* 03RocketRace 5*  10uploaded "[[02File:Linear transformation latex.gif10]]"
2020-08-30 03:34:19 <esowiki> 14[[071CP=1ICL14]]4 10 02https://esolangs.org/w/index.php?diff=77119&oldid=77114 5* 03RocketRace 5* (+321) 10\
2020-08-30 03:36:39 Joined: adu
2020-08-30 03:36:39 Names: ^[, adu, aloril, APic, Arcorann, ATMunn, b_jonas, Bowserinator, BWBellairs, Cale, catern, clog, Deewiant, diginet, dingwat, diverger, dnm, dog_star, egelbot, erdic, esowiki, FireFly, fizzie, FreeFull, fungot, gitlogger, glowcoil, grumble, haavard, HackEso, hakatashi, hendursaga, heroux, Hooloovo0, imode, int-e, interruptinuse, iovoid, iscordian[m], izabera, j-bot, j4cbo, jix, joast, kkd, kmc, laerling, lambdabot, lifthrasiir, Lord_of_Life, Lymia, Melvar, mich181189, mniip, moony, myname, myndzi, ocharles, olsner, orbitaldecay, oren, ornxka, paul2520, pikhq, ProofTechnique, rain1, relrod, rodgort, sebbu, sftp, Sgeo, shachaf, shikhin, ski, Soni, sparr, sprocklem, spruit11, stux, Taneb, trn, tromp, tswett[m], uplime, V, vertrex, wmww, xelxebar, zeroed, zzo38
2020-08-30 03:37:01 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77120&oldid=77119 5* 03RocketRace 5* (+26) 10/* Language specifications */
2020-08-30 03:51:46 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77121&oldid=77120 5* 03RocketRace 5* (+222) 10
2020-08-30 03:52:37 <esowiki> 14[[071CP=1ICL14]]4 M10 02https://esolangs.org/w/index.php?diff=77122&oldid=77121 5* 03RocketRace 5* (+12) 10/* Language specifications */
2020-08-30 03:57:33 <esowiki> 14[[07Babalang14]]4 10 02https://esolangs.org/w/index.php?diff=77123&oldid=76378 5* 03RocketRace 5* (+0) 10Remove from 2020 category and put into 2019 category
2020-08-30 03:58:00 <esowiki> 14[[07Babalang14]]4 M10 02https://esolangs.org/w/index.php?diff=77124&oldid=77123 5* 03RocketRace 5* (+0) 10Undo revision 77123 by [[Special:Contributions/RocketRace|RocketRace]] ([[User talk:RocketRace|talk]])
